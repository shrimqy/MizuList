// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") //database connector 
}

//schema

model User {
  id            String   @id @default(cuid())
  username      String   @unique
  passwordHash  String
  userAuthToken String   @unique
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  avatar        String?
  bio           String?

  role         Roles          @relation(fields: [roleID], references: [id])
  roleID       Int
  followedBy   User[]         @relation("UserFollows")
  following    User[]         @relation("UserFollows")
  bookCategory BookCategory[] @relation("UserBookCategory")

  reviews       review[]
  userBooks     UserBook[]
  activity      activity[]
  likes         Like[]
  dislike       DisLike[]
  Comment       Comment[]
  Favorite      Favorite[]
  status        status[]
  Thread        Thread[]
  viewedThreads Thread[]   @relation("ViewedThreads")
}

model BookCategory {
  id       Int        @id @default(autoincrement())
  name     String     @unique
  UserBook UserBook[] @relation("BookCategory")
  User     User[]     @relation("UserBookCategory")
  activity activity[]
}

model Roles {
  id    Int    @id @default(autoincrement())
  name  String @unique
  users User[]
}

model Favorite {
  id     String @id @default(uuid())
  book   Book   @relation(fields: [bookID], references: [id], onDelete: Cascade, onUpdate: Cascade)
  bookID String
  user   User[]
}

model Book {
  id             String  @id
  bookID         String?
  romanizedTitle String?
  englishTitle   String?
  nativeTitle    String?
  authors        String?
  Description    String?
  format         String?
  isbn           String?
  pages          String?
  chapters       String?
  views          Int?

  amazonUrl      String?
  coverUrl       String?
  publicRating   Float?
  ratingCount    Int?
  firstPublished DateTime?
  publisher      String?
  createdAt      DateTime  @default(now())

  tag               Tag[]
  genres            Genres[]
  userBooks         UserBook[]
  SeriesBook        SeriesBook[]
  Favorite          Favorite[]
  review            review[]
  activity          activity[]
  recommendedBooks1 Recommendation[] @relation("Book1Recommendations")
  recommendedBooks2 Recommendation[] @relation("Book2Recommendations")
  thread            Thread[]         @relation("bookThread")
}

model Series {
  id          String       @id
  name        String       @unique
  description String?
  SeriesBook  SeriesBook[]
}

model SeriesBook {
  series   Series  @relation(fields: [seriesID], references: [id], onUpdate: Cascade)
  seriesID String
  book     Book    @relation(fields: [bookID], references: [id], onDelete: Cascade)
  bookID   String
  order    String?

  @@id([bookID, seriesID])
}

model Genres {
  id    Int    @id @default(autoincrement())
  label String
  book  Book[]
}

model Tag {
  id   Int    @id @default(autoincrement())
  Tag  String
  book Book[]
}

model UserBook {
  id           String         @id @default(uuid())
  user         User           @relation(fields: [userID], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userID       String
  book         Book           @relation(fields: [bookID], references: [id], onDelete: Cascade, onUpdate: Cascade)
  bookID       String
  bookCategory BookCategory[] @relation("BookCategory")

  pagesRead    String?
  chaptersRead String?
  rating       String?
  rereads      String?
  notes        String?
  startedDate  DateTime?
  lastUpdated  DateTime? @updatedAt
  completedAt  DateTime?

  @@unique([userID, bookID]) // Ensures a user has only one entry per book
}

model review {
  id             String   @id @default(uuid())
  date           DateTime @updatedAt
  review         String
  recommendation String
  spoiler        String
  rating         String?
  title          String?

  book   Book    @relation(fields: [bookID], references: [id])
  bookID String
  user   User?   @relation(fields: [userID], references: [id])
  userID String?
}

model activity {
  id        String   @id @default(cuid())
  timestamp DateTime @default(now())
  chapter   String?
  rating    String?
  title     String?
  pages     String?

  book       Book          @relation(fields: [bookID], references: [id])
  bookID     String
  user       User?         @relation(fields: [userID], references: [id])
  userID     String?
  category   BookCategory? @relation(fields: [categoryId], references: [id])
  categoryId Int?

  like    Like[]
  comment Comment[]
}

model status {
  id        String   @id @default(uuid())
  text      String?
  timestamp DateTime @default(now())

  user    User      @relation(fields: [userID], references: [id])
  userID  String
  like    Like[]
  comment Comment[]
}

model Comment {
  id        Int       @id @default(autoincrement())
  comment   String
  createdAt DateTime? @default(now())

  Children  Comment[] @relation("Comment_Children")
  parent    Comment?  @relation("Comment_Children", fields: [parent_id], references: [id])
  parent_id Int?

  user       User      @relation(fields: [userID], references: [id])
  userID     String
  status     status?   @relation(fields: [statusId], references: [id])
  statusId   String?
  activity   activity? @relation(fields: [activityId], references: [id])
  activityId String?
  Like       Like[]
  Thread     Thread?   @relation(fields: [threadId], references: [id])
  threadId   String?
}

model Recommendation {
  id      String    @id @default(uuid())
  book1   Book      @relation("Book1Recommendations", fields: [book1Id], references: [id])
  book1Id String
  book2   Book      @relation("Book2Recommendations", fields: [book2Id], references: [id])
  book2Id String
  Like    Like[]
  DisLike DisLike[]
}

model Like {
  id               String          @id @default(cuid())
  activity         activity?       @relation(fields: [activityId], references: [id])
  activityId       String?
  recommendation   Recommendation? @relation(fields: [recommendationId], references: [id])
  recommendationId String?
  status           status?         @relation(fields: [statusId], references: [id])
  statusId         String?
  comment          Comment?        @relation(fields: [commentID], references: [id])
  commentID        Int?
  User             User?           @relation(fields: [userId], references: [id])
  userId           String?
}

model DisLike {
  id               String          @id @default(cuid())
  recommendation   Recommendation? @relation(fields: [recommendationId], references: [id])
  recommendationId String?
  User             User?           @relation(fields: [userId], references: [id])
  userId           String?
}

model Thread {
  id          String    @id
  title       String
  views       Int?      @default(0)
  threadBody  String?
  isPinned    Boolean?  @default(false)
  isLocked    Boolean?  @default(false)
  createdAt   DateTime? @default(now())
  lastUpdated DateTime? @updatedAt

  category ThreadCategory[]
  book     Book[]           @relation("bookThread")
  Comment  Comment[]
  user     User?            @relation(fields: [userID], references: [id])
  userID   String?
  viewedBy User[]           @relation("ViewedThreads")
}

model ThreadCategory {
  id     Int      @id @default(autoincrement())
  name   String?
  color  String?
  thread Thread[]
}

// Use enums when yosu change database
// because SQLite doesn't support it
// https://www.prisma.io/docs/reference/database-reference/database-features#misc
